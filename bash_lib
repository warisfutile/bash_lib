#!/bin/bash
# ###########################
# Bash Shell Function Library
# ###########################
#
# Copyright 2013
# Author: Will Bentley WBentley@futurecis.com
# License: Released under the current GPL Version 2 License .
# Description: This is a shell script library that contains the most common functions to save some coding.
#
#Purpose:
#Required Variables:
#Optional Variables:
#Minimum Arguments:
#Functions Required: None

# 1.00 Initial Release

LIB_SVER="1.00"

#Determine if script is called directly or being sourced by an outside script
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
  lib_sourced="true"
  LIB_SNAME="bash_lib"
  #echo "Script \"${BASH_SOURCE[0]}\" is being sourced ..."
else
  lib_sourced="false"
  LIB_SNAME="`basename ${0}`"
  #echo "Script is not being sourced"
fi

#Set all the default PATHS normally used
export PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:${PATH}"

# Must set this option, else script will not expand aliases.
shopt -s expand_aliases

#Ensure echo can use regex
alias echo="echo -e"

#Capture curren input field separator
export CURRENTIFS="${IFS}"

#Specify if sudo should be used or not
if [[ ${UID} = "0" ]]; then
  SUDO=""
else
  SUDO="sudo "
fi

#Determine if we can use the read command or accept input
if [[ ${lib_sourced} = "true" ]]; then
  INTERACTIVE="true"
else
  INTERACTIVE="false"
fi

##############################
# Begin Function Declaration #
##############################
function abort {
# Purpose: Function for major errors & Exits
# Required Variables: LOG_FILE
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: has_value, logit
# Example Call: abort 1

  #Define abort codes
  abort_msg_0="General Exit; no issue"
  abort_msg_1="General Error"
  abort_msg_2="Missing Keyword or Command"
  abort_msg_10="Unable to find or install/remove packages"
  abort_msg_11="Unable to update LDAP configuration"
  abort_msg_12="Unable to configure or manage service"
  abort_msg_13="Unable to modify LDAP entry"
  abort_msg_14="Unable to Start/Restart Service"
  abort_msg_15="Unable to perform operations against server"
  abort_msg_16="Unable to find or access file"
  abort_msg_17="User not found"
  abort_msg_18="Incorrect Password"
  abort_msg_19="Unable to modify permissions/ownership"
  abort_msg_20="Unable to create/remove file/directory"
  abort_msg_21="Unable to modify user/group account"
  abort_msg_22="Variable Undefined"
  abort_msg_23="System is not an LDAP client"
  abort_msg_24="Unable to access/modify device"
  abort_msg_126="Permission problem or command is not an executable"
  abort_msg_127="Command Not Found"
  abort_msg_128="Invalid Exit Status"
  abort_msg_130="Script Terminated by Control-C"
  abort_msg_131="Script Terminated by SIGKILL"
  abort_msg_132="Script Terminated by SIGTERM"
  abort_msg_133="Script Terminated by SIGSTOP"
  abort_msg_134="Script Terminated by SIGTSTP"

  if [[ ${1} = "report" ]]; then
    return 0
  fi

  var_check ${FUNCNAME} 1 DEBUG
  var_check ${FUNCNAME} 1 LOG_FILE
  abort_code="${1}"
  if [[ `has_value ${2}` ]]; then
    abort_files="${2}"
  fi
  typeset abort_status=${abort_code:-1}  # Exit 1 unless specified
  if [[ `has_value ${abort_files}` ]]; then
    cleanup abort ${abort_files}
  fi

  #Choose abort code
  case "${abort_status}" in
    "0")
      abort_msg="${abort_msg_0}"
    ;;
    "1")
      abort_msg="${abort_msg_1}"
    ;;
    "2")
      abort_msg="${abort_msg_2}"
    ;;
    "10")
      abort_msg="${abort_msg_10}"
    ;;
    "11")
      abort_msg="${abort_msg_11}"
    ;;
    "12")
      abort_msg="${abort_msg_12}"
    ;;
    "13")
      abort_msg="${abort_msg_13}"
    ;;
    "14")
      abort_msg="${abort_msg_14}"
    ;;
    "15")
      abort_msg="${abort_msg_15}"
    ;;
    "16")
      abort_msg="${abort_msg_16}"
    ;;
    "17")
      abort_msg="${abort_msg_17}"
    ;;
    "18")
      abort_msg="${abort_msg_18}"
    ;;
    "19")
      abort_msg="${abort_msg_19}"
    ;;
    "20")
      abort_msg="${abort_msg_20}"
    ;;
    "21")
      abort_msg="${abort_msg_21}"
    ;;
    "22")
      abort_msg="${abort_msg_22}"
    ;;
    "23")
      abort_msg="${abort_msg_23}"
    ;;
    "24")
      abort_msg="${abort_msg_24}"
    ;;
    "126")
      abort_msg="${abort_msg_126}"
    ;;
    "127")
      abort_msg="${abort_msg_127}"
    ;;
    "128")
      abort_msg="${abort_msg_128}"
    ;;
    "130")
      abort_msg="${abort_msg_130}"
    ;;
    "131")
      abort_msg="${abort_msg_131}"
    ;;
    "132")
      abort_msg="${abort_msg_132}"
    ;;
    "133")
      abort_msg="${abort_msg_133}"
    ;;
    "134")
      abort_msg="${abort_msg_134}"
    ;;
    * )
      echo "Invalid exit code"
    ;;
  esac
  logit -s "EXIT ${abort_status} abort: ${abort_msg}"
  if [[ ${abort_status} != "0" ]]; then
    echo "\nScript exited abnormally; see error log for more info.\nLog: ${LOG_FILE}"
  fi
  if `option_enabled DEBUG` && `file_exists ${LOG_FILE_DEBUG}`; then
    echo "\nDebug file is located at ${LOG_FILE_DEBUG}\n"
  fi
  IFS="${CURRENTIFS}"
  exit ${abort_code}
}


function backup {
# Purpose: Backup a file to same location with date stamp appended to name
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: DATE3 logit
# Example Call: backup /etc/passwd
  backup_file=${1}.$(DATE3)
  if [[ -f ${1} ]] ; then
    logit "Backing up ${1} to ${backup_file}"
    cp -p ${1} ${backup_file}
  fi
  return 0
}


function byteme {
# Purpose: Convert integer to human readable size. i.e. 8.9TB instead of 9876543212345
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 2
# Functions Required: has_value
# Example Call: byteMe 2048 K

# Usage
# ${1} = Number to convert (Expects bytes)
# ${2} = Letter of byte typ you are passing in (K,M,G,T,X,P)
# Divides by 2^10 until < 1024 and then append metric suffix
  if [[ ! `has_value ${1}` ]] && [[ ! `has_value ${2}` ]]; then
    echo ""
    echo "  Usage: byteme VALUE [SIZE]"
    echo "    VALUE  Number to be converted"
    echo "    SIZE   Specify what type VALUE is; (K, M, G, T, X, P) Defaults to Bytes"
    echo ""
    echo "    Example: byteme 1024 M"
    echo "    Returns: 1.0GB"
    echo ""
    return 1
  fi
  if [[ ${2} = "K" ]]; then
    declare -a METRIC=('KB' 'MB' 'GB' 'TB' 'XB' 'PB') # Array of suffixes
  elif [[ ${2} = "M" ]]; then
    declare -a METRIC=('MB' 'GB' 'TB' 'XB' 'PB') # Array of suffixes
  elif [[ ${2} = "G" ]]; then
    declare -a METRIC=('GB' 'TB' 'XB' 'PB') # Array of suffixes
  elif [[ ${2} = "T" ]]; then
    declare -a METRIC=('TB' 'XB' 'PB') # Array of suffixes
  elif [[ ${2} = "X" ]]; then
    declare -a METRIC=('XB' 'PB') # Array of suffixes
  elif [[ ${2} = "P" ]]; then
    METRIC='PB' # Array of suffixes
  else
    declare -a METRIC=('Bytes' 'KB' 'MB' 'GB' 'TB' 'XB' 'PB') # Array of suffixes
  fi
  MAGNITUDE=0  # magnitude of 2^10
  PRECISION="scale=1" # change this numeric value to inrease decimal precision
  UNITS=`echo ${1} | tr -d .,.`  # numeric arg val (in bytes) to be converted
  while [ ${UNITS/.*} -ge 1024 ]; do # compares integers (b/c no floats in bash)
    UNITS=`echo "${PRECISION}; ${UNITS}/1024" | bc` # floating point math via `bc`
    ((MAGNITUDE++)) # increments counter for array pointer
  done
  echo "${UNITS} ${METRIC[$MAGNITUDE]}"
  return 0
}


function check {
# Purpose: Function for checking last process success and reporting message as well as line number
# Required Variables: None
# Optional Variables: See below
# Minimum Arguments: 3
# Functions Required: has_value
# Example Call: check ${LINENO} "Failed to add entry to LDAP" 13 my_exit_function
# Example Call2: check ${LINENO} failed "Failed to add entry to LDAP" 13 my_exit_function
  check_rc="${?}"
  if [[ ${2} = "failed" ]]; then
    check_line="${1}"
    check_msg="${3}"
    check_code="${4}"
    check_rc="${check_code}"
    check_function_call="${5}"
  else
    check_line="${1}"
    check_msg="${2}"
    check_code="${3}"
    check_function_call="${4}"
  fi
  dbg ${FUNCNAME} ${LINENO} "check_rc: ${check_rc}"

  if [[ ${check_rc} != "0" ]]; then
    if `has_value check_function_call`; then
      #If $function is defined; pass variables to it; note, expect function_call to perform logging
      dbg ${FUNCNAME} ${LINENO} "Calling external function call" "${check_function_call} \"${check_line}\" \"${check_msg}\" \"${check_code}\""
      ${check_function_call} "${check_line}" "${check_msg}" "${check_code}"
    else
      #Return code is not zero, log this
      logit "EXIT: ${check_code} ${check_line}: ${check_msg}"
      return ${check_code}
    fi
  else
    return 0
  fi
}


function check_update {
# Purpose: This function should be called at the beginning of your script execution to ensure the user is runnning the most current version of your script. NOTE: Your script should support a -v option and output the following "Version: 2.01"
# Required Variables: CUSTOM_SCRIPTS_LOCALE, SNAME, SVER
# Optional Variables: All arfuments passed into script $@
# Minimum Arguments: 1
# Functions Required: None
# Example Call: check_update ${all_arguments}
  all_args="$@"
  #Check for required variables
  var_check ${FUNCNAME} 1 CUSTOM_SCRIPTS_LOCALE
  var_check ${FUNCNAME} 1 SNAME
  var_check ${FUNCNAME} 1 SVER
  # Check for a newer version of the script
  if [[ `file_exists ${CUSTOM_SCRIPTS_LOCALE}/${SNAME}` ]]; then
    new_ver="`${CUSTOM_SCRIPTS_LOCALE}/${SNAME} -v | grep Version: | cut -d: -f2 | perl -pe 's/ //g'`"
    current_ver_whole="`echo ${SVER} | perl -pe 's/\.//g'`"
    new_ver_whole="`echo ${new_ver} | perl -pe 's/\.//g'`"
    if [[ ${new_ver_whole} -gt ${current_ver_whole} ]]; then
      echo "A newer version of '${SNAME}' is available. You must use the newer version to continue"
      echo "   Current Version: ${SVER}"
      echo "   Newer Version:   ${new_ver}"
      echo "   Location:        ${CUSTOM_SCRIPTS_LOCALE}/${SNAME}"
      echo ""
      echo ""
      read -s -n 1 -p "Press any key to launch the newer script..."
      echo "Launching newer version with same options..."
      echo "    Executing: ${CUSTOM_SCRIPTS_LOCALE}/${SNAME} ${all_args}"
      sleep 3
      ${CUSTOM_SCRIPTS_LOCALE}/${SNAME} ${all_args}
      exit 0
    fi
  fi
  return 0
}


function cleanup {
# Purpose: Function for removing old files
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: cleanup /tmp/test1 /tmp/test2
  if [[ ${1} = "abort" ]]; then
    cleanup_files="${2}"
  else
    # Dont display this if called from abort function
    echo "Cleaning up...."
    cleanup_files="${@}"
  fi
  if ! `has_value ${cleanup_files}`; then
    echo "Deleting temp files: ${cleanup_files}"
    #Add safety catch to avoid deleting root
    if [[ ${cleanup_files} = "/" ]]; then
      echo "ERROR: cleanup_files variable in ${FUNCNAME} from ${0} has specified deleting all of root; I'm sorry Dave, I cannot allow that"
      exit 1
    else
      rm -f ${cleanup_files}
    fi
  fi
  sleep 1
  return 0
}


function DATE1 {
# Purpose: Return current date in format of  2012-03-01-18:53:22
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: DATE1
  date "+%Y-%m-%d-%H:%M:%S"
  return 0
}


function DATE2 {
# Purpose: Return current date in format of Mar 01 2012 18:53:22
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: DATE2
  date "+%b %d %Y %H:%M:%S"
  return 0
}


function DATE3 {
# Purpose: Return current date in format of 20120301185322
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: DATE3
  date "+%Y%m%d%H%M%S"
  return 0
}


function DATE4 {
# Purpose: Return current date in format of 2012030118
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: DATE4
  date "+%Y%m%d%H"
  return 0
}


function dir_exists {
# Purpose: Check if directory exists
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: dir_exists /tmp
  if [[ -d "${1}" ]]; then
    return 0
  fi
  return 1
}


function dbg {
# Purpose: Function dbg message handling and logging for various levels
# Required Variables: DEBUG_HOST DEBUG_LEVEL
# Optional Variables: See below
# Minimum Arguments: 3
# Functions Required: is_defined, get_os, DATE2
# Example Call: dbg ${FUNCNAME} ${LINENO} "Unable to determine hostname" "hostname"

# Debugging function
# $1 -- Function that is executing
# $2 -- Line number of dbg statement via $LINENO (optional)
# $3 -- Message to be displayed
# $4 -- Command that was executed (optional)
# Debug Levels
# Level 1: Display to screen only
# Level 2: Send to LOG_FILE_DEBUG only
# Level 3: Display and send to LOG_FILE_DEBUG
# Level 4: Full set -x to screen
# Level 5: Full set -x to screen and DEBUG statements
  #Only continue if DEBUG is enabled
  if [[ ${DEBUG} != "true" ]]; then
     return 0
  fi
  var_check ${FUNCNAME} 1 DEBUG_HOST
  var_check ${FUNCNAME} 1 DEBUG_LEVEL
  var_check ${FUNCNAME} 1 LOG_FILE_DEBUG
  if ! `is_defined OS_HOSTNAME` ; then
    #OS function has not been executing, doing so now
    get_os
  fi

  #Ensure that the current host is equal to the debug host
  if [[ ${DEBUG_HOST} = ${OS_HOSTNAME} ]] || [[ ${DEBUG_HOST} = `echo ${OS_HOSTNAME} | cut -d. -f1` ]]; then
    debug_host_correct="true"
  else
    debug_host_correct="false"
  fi

  if `option_enabled debug_host_correct` && [[ ${DEBUG_LEVEL} != "0" ]]; then
    #Argument 1
    debug_function_call="${1}"

    #Argument 2
    if `is_number ${2}`; then
      debug_line="Line: ${2}  "
    else
      debug_line=""
    fi

    #Argument 3
    debug_msg="${3}"

    #Argument 4
    debug_cmd="${4}"

    #Dont run dbg for a given section if per section dbg is set to false
    eval section_var="\$${debug_function_call}_dbg" 2>/dev/null
    if [[ ${section_var} = "false" ]]; then
      return 0
    fi

    #Account for xtrace first
    if [[ ${DEBUG_LEVEL} = "4" ]] || [[ ${DEBUG_LEVEL} = "5" ]]; then
      set -x
      return 0
    else
      xtrace="set +x"
    fi

    #Main message passed in
    if [[ ${DEBUG_LEVEL} = "1" ]] || [[ ${DEBUG_LEVEL} = "3" ]] || [[ ${DEBUG_LEVEL} = "5" ]]; then
      echo "###DEBUG  $(DATE2) ${debug_line}FUNCTION: ${debug_function_call}   MESSAGE: \"${debug_msg}\""
    fi
    if [[ ${DEBUG_LEVEL} = "2" ]] || [[ ${DEBUG_LEVEL} = "3" ]]; then
      echo "###DEBUG  $(DATE2) ${debug_line}FUNCTION: ${debug_function_call}   MESSAGE: \"${debug_msg}\"" >> ${LOG_FILE_DEBUG}
    fi

    #Additonal CMD is passed in
    if [[ ${debug_cmd} != "" ]]; then
      if [[ ${DEBUG_LEVEL} = "1" ]] || [[ ${DEBUG_LEVEL} = "3" ]] || [[ ${DEBUG_LEVEL} = "5" ]]; then
        echo "###DEBUG        COMMAND: ${debug_cmd}"
      fi
      if [[ ${DEBUG_LEVEL} = "2" ]] || [[ ${DEBUG_LEVEL} = "3" ]]; then
        echo "###DEBUG        COMMAND: ${debug_cmd}" >> ${LOG_FILE_DEBUG}
      fi
    fi
  fi
  return 0
}


function file_exists {
# Purpose: Check if file exists
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: file_exists /etc/hosts
  if [[ -f "${1}" ]]; then
    return 0
  fi
  return 1
}


function get_ldap {
# Purpose: Set/get LDAP variables
# Required Variables: LDAP_USER, LDAP_ADMIN_BINDDN, LDAP_ADMIN_BINDPW
# Optional Variables: LDAP_HOST, LDAP_BINDDN, LDAP_BINDPW, LDAP_PORT, LDAP_BASEDN
# Minimum Arguments: 0
# Functions Required: has_value
# Example Call: get_ldap
  var_check ${FUNCNAME} 1 LDAP_USER
  # Check if already an LDAP client
  id ${LDAP_USER} > /dev/null 2>&1
  if [[ ${?} != "0" ]]; then
    LDAP_CLIENT="false"
  else
    LDAP_CLIENT="true"
  fi

  #LDAP_HOST
  if ! `has_value LDAP_HOST` ; then
    LDAP_HOST=`grep -i ^uri /etc/ldap.conf 2>/dev/null | awk '{print $2}' | cut -d\/ -f3`
  fi
  if `has_value LDAP_HOST` ; then
    ldap_host="-h ${LDAP_HOST}"
  fi


  #LDAP_BINDDN
  if ! `has_value LDAP_BINDDN` ; then
    LDAP_BINDDN=`grep -i ^binddn /etc/ldap.conf 2>/dev/null | awk '{print $2}'`
    if ! `has_value LDAP_BINDDN` ; then
      LDAP_BINDDN="null"
    fi
  fi
  if `has_value LDAP_BINDDN` ; then
    ldap_binddn="-D ${LDAP_BINDDN}"
  else
    ldap_binddn=""
  fi


  #LDAP_BINDPW
  if ! `has_value LDAP_BINDPW` ; then
    LDAP_BINDPW=`grep -i ^bindpw /etc/ldap.conf 2>/dev/null | awk '{print $2}'`
    if ! `has_value LDAP_BINDPW` ; then
      ldap_binddn="null"
    fi
  fi
  if `has_value LDAP_BINDPW`; then
    ldap_bindpw="-w ${LDAP_BINDPW}"
  else
    ldap_bindpw=""
  fi


  #LDAP_ADMINDN
  if ! `has_value LDAP_ADMINDN`; then
    ldap_admindn=""
  else
    ldap_admindn="-D ${LDAP_ADMINDN}"
  fi

  #LDAP_ADMINPW
  if ! `has_value LDAP_ADMINPW` ; then
    ldap_adminpw=""
  else
    ldap_adminpw="-w ${LDAP_ADMINPW}"
  fi

  #LDAP_PORT
  if ! `has_value LDAP_PORT` ; then
    LDAP_PORT=`grep -i ^port /etc/ldap.conf 2>/dev/null | awk '{print $2}'`
  fi
  if `has_value LDAP_PORT` ; then
    ldap_port="-p ${LDAP_PORT}"
  fi

  #LDAP_BASEDN
  if ! `has_value LDAP_BASEDN` ; then
    LDAP_BASEDN=`grep -i ^base /etc/openldap/ldap.conf 2>/dev/null | awk '{print $2}'`
  fi
  if `has_value LDAP_BASEDN` ; then
    ldap_basedn="-b ${LDAP_BASEDN}"
  fi

  #LDAP_TLS
  if ! `has_value LDAP_TLS` ; then
    if [[ `grep -i ^'ssl start_tls' /etc/ldap.conf 2>/dev/null` ]]; then
      LDAP_TLS="true"
    fi
  fi
  if `option_enabled LDAP_TLS` ; then
     ldap_tls="ZZ"
  fi

  #LDAP_SSL
  if ! `has_value LDAP_SSL` ; then
    if [[ `grep -i ^'ssl yes' /etc/ldap.conf 2>/dev/null` ]]; then
      LDAP_SSL="true"
    fi
  fi
  var_check ${FUNCNAME} 2 LDAP_BINDDN
  var_check ${FUNCNAME} 2 LDAP_BINDPW
  var_check ${FUNCNAME} 3 LDAP_ADMINDN
  var_check ${FUNCNAME} 3 LDAP_ADMINPW

  #Build LDAP search command
  export LDAP_SEARCH="ldapsearch -xLLL${ldap_tls} ${ldap_host} ${ldap_basedn} ${ldap_port} ${ldap_binddn} ${ldap_bindpw}"
  export LDAP_SEARCH_NP="ldapsearch -xLLL${ldap_tls} ${ldap_host} ${ldap_basedn} ${ldap_port} ${ldap_binddn} -w \${ldap_bindpw}"
  export LDAP_MODIFY="ldapmodify -x${ldap_tls} ${ldap_host} ${ldap_port} ${ldap_admindn} ${ldap_adminpw}"
  export LDAP_MODIFY_NP="ldapmodify -x${ldap_tls} ${ldap_host} ${ldap_port} ${ldap_admindn} -w \${ldap_adminpw}"
  export LDAP_DELETE="ldapdelete -x${ldap_tls} ${ldap_host} ${ldap_port} ${ldap_admindn} ${ldap_adminpw}"
  export LDAP_DELETE_NP="ldapdelete -x${ldap_tls} ${ldap_host} ${ldap_port} ${ldap_admindn} -w \${ldap_adminpw}"
  return 0
}

function get_os {
# Purpose: Call this function when you need all system related info
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 0
# Functions Required: None
# Example Call: get_os
  #Get hostname; validate through DNS if possible
  export OS_HOSTNAME=`nslookup $(hostname) | grep Name | awk '{print $2}'`
  if [[ -z ${OS_HOSTNAME} ]]; then
    export OS_HOSTNAME=`hostname`
  fi
  # Short Hostname (Non-fully qualified)
  export OS_SHOSTNAME=`echo ${OS_HOSTNAME} | cut -d. -f1`
  OS_HOSTNAME_ALIAS=`nslookup ${OS_SHOSTNAME} | grep canonical | awk '{print $1}' | cut -d. -f1`
  OS_DOMAIN="`echo ${OS_HOSTNAME} | cut -d. -f2-`"

  # Determine Processor architecture
  if [[ `uname -m` = x86_64 ]]; then
    OS_ARCH="64-bit"
  else
    OS_ARCH="32-bit"
  fi
  OS_KERNEL="`uname -r`"
  # Determine OS Version
  if [[ -f /etc/redhat-release ]]; then
    export OS_RELEASE=`cat /etc/redhat-release | awk '{print $7}'`
    if [[ -d /opt/oracle.SupportTools ]] || [[ `chkconfig --list | grep ovmd` ]]; then
      OS_INFO="OEL ${OS_RELEASE} Kernel: ${OS_KERNEL}"
    else
      OS_INFO="RHEL ${OS_RELEASE} Kernel: ${OS_KERNEL}"
    fi
    OS_VERSION="`echo ${OS_RELEASE} | cut -d. -f1`"
  else
    OS_INFO=`uname -rs`
  fi

  if [[ `${SUDO}cat /var/log/dmesg 2>/dev/null | grep -i VMWare | grep BIOS` ]]; then
    OS_VIRTUALIZED="Virtualized via VMWARE"
  elif [[ `${SUDO}cat /var/log/dmesg 2>/dev/null | grep -i RHEV` ]]; then
    OS_VIRTUALIZED="Virtualized via RHEV"
  elif [[ `${SUDO}cat /var/log/dmesg 2>/dev/null | grep -i Xen` ]]; then
    OS_VIRTUALIZED="Virtualized via XEN"
  elif [[ `${SUDO}cat /var/log/dmesg 2>/dev/null | grep -i kvm | grep -v 'kvm:'` ]]; then
    OS_VIRTUALIZED="Virtualized via KVM"
  elif [[ `${SUDO}cat /var/log/dmesg 2>/dev/null | grep -i qemu` ]]; then
    OS_VIRTUALIZED="Virtualized via QEMU"
  else
    OS_VIRTUALIZED="Not Virtualized; PHYSICAL"
  fi

  #Determin CPU Info
  OS_CPU_TYPE="`grep 'model name' /proc/cpuinfo | cut -d: -f2- | head -1 | xargs | awk '{print $1,$2,$4}'`"
  if [[ `echo ${OS_CPU_TYPE} | grep -i not` ]]; then
    OS_CPU_TYPE=`lshal | grep -i cpu | grep info.product | sort -u | cut -d\' -f2 | perl -pe 'g/s/\(.*?\)//g'`
  elif [[ ${OS_CPU_TYPE} = "" ]]; then
    OS_CPU_TYPE="UNKNOWN"
  fi

  # Determine CPU Quantity
  # cpu: Actual physical processors on the host; sockets
  # core: Cores avilable per CPU
  # ht: Hyperthread (virtaul cores) per core/cpu
  #If system is OS_VIRTUALIZED
  OS_CPU_QTY="`grep "physical id" /proc/cpuinfo | sort | uniq | wc -l | xargs`"
  if [[ ! `echo ${OS_VIRTUALIZED} | grep Not` ]]; then
    OS_CPU_QTY="`grep ^processor /proc/cpuinfo | wc -l`"
    OS_CORE_QTY="${OS_CPU_QTY}"
    OS_HT_QTY="${OS_CPU_QTY}"
  else #This is a physical host; non-OS_VIRTUALIZED
    #OS_CPU_QTY stays the same
    OS_CORE_QTY="`egrep 'core id|physical id' /proc/cpuinfo | tr -d '\n' | sed s/physical/\\\nphysical/g | grep -v '^$' | sort -u | wc -l`"
    OS_HT_QTY="`grep '^processor' /proc/cpuinfo | wc -l`"
  fi
  cores_per_cpu=$(( ${OS_CORE_QTY} / ${OS_CPU_QTY} ))

  # Determine CPU Frequency
  OS_CPU_FREQ="`grep 'model name' /proc/cpuinfo | head -1 | cut -d@ -f2 | xargs`"
  if [[ ${OS_CPU_FREQ} = "" ]]; then
    OS_CPU_FREQ=""
  else
    OS_CPU_FREQ="@ ${OS_CPU_FREQ}"
  fi

  # Put all CPU info together now
  if [[ ${OS_CORE_QTY} != "" ]]; then
    os_core_info="with ${OS_CORE_QTY} (${OS_HT_QTY} hyper-threaded) core(s) each ${OS_CPU_FREQ} `uname -m`"
  else
    os_core_info="`uname -m`"
  fi
  OS_PROC_INFO="${OS_CPU_QTY} ${OS_CPU_TYPE} ${os_core_info}"

  # Determine RAM amount
  totalram=`grep MemTotal /proc/meminfo | awk '{print $2}'`
  let totalram="${totalram} / 1024 / 1024"
  OS_RAM="${totalram}G"

  #Get some network Info
  OS_GATEWAY=`ip route | grep default | awk '{print $3}'`
  OS_DEFAULT_INTERFACE="`ip route | grep default | awk '{print $5}'`"
  OS_PRIMARY_IP="`nslookup ${OS_HOSTNAME} | grep ^Address | grep -v \# | awk '{print $2}'`"
  #If unable to determine IP from DNS, try to get locally configured IP based on default route
  if [[ ${OS_PRIMARY_IP} = "" ]]; then
    OS_PRIMARY_IP="`ifconfig ${OS_DEFAULT_INTERFACE} | grep 'inet addr' | cut -d: -f2 | awk '{print $1}'`"
    if [[ ${OS_PRIMARY_IP} = "" ]]; then
       #Unable to determine primary IP; defaulting to a safe value
       OS_PRIMARY_IP="127.0.0.1"
    fi
  fi
  OS_ADDITIONAL_IPS="`ifconfig | grep 'inet addr' | awk {'print $2'} | cut -d: -f2 | grep -v ^127 | grep -v ${OS_PRIMARY_IP} | xargs`"
  return 0
}


function get_password {
# Purpose: Prompt the user twice for password to check for mismatches: New password is stored in $PASSWORD. If the -c option is passed in, it will prmpt for password again to provide confirmation that passwords match
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: get_password root
  CURRENTIFS="${IFS}"
  PASSWORD=1
  PASSWORDv=2
  if [[ ${1} = "-c" ]]; then
    password_confirm="true"
    password_user="${2}"
  else
    password_confirm="false"
    password_user="${1}"
  fi

  #Begin prompting for password
  while [[ "${PASSWORD}" != "${PASSWORDv}" ]] || [[ "${PASSWORD}" = "" ]]; do
    PASSWORD=""
    PASSWORDv=""
    # Capture password to be used
    prompt="Please Enter the Password for ${password_user}: "
    echo ""
    while IFS= read -p "${prompt}" -r -s -n 1 char; do
      if [[ ${char} == $'\0' ]]; then
        break
      fi
      prompt="*"
      PASSWORD+="${char}"
      IFS=""
    done

    #If -c was passed in, then prompt again and verify
    if [[ ${password_confirm} = "true" ]]; then
      # Capture verification password
      prompt="Please Enter the Password for ${password_user} again: "
      echo ""
      while IFS= read -p "${prompt}" -r -s -n 1 char; do
        if [[ ${char} == $'\0' ]]; then
          break
        fi
        prompt="*"
        PASSWORDv+="${char}"
        IFS=""
      done
      if [[ "${PASSWORD}" != "${PASSWORDv}" ]]; then
        echo;echo "MisMatch - try again"
      else
        PASSWORD="${PASSWORD}"
      fi
    else
      PASSWORDv="${PASSWORD}"
    fi
    if [[ ${PASSWORD} = "" ]]; then
      echo;echo "Password cannot be blank"
    fi
  done

  IFS=${CURRENTIFS}
  CURRENTIFS=""
  echo ""
  return 0
}


function get_user {
# Purpose: Obtain and validate a user's LDAP/local info
# Required Variables: LDAP_USER, INTERACTIVE, LDAP_CLIENT
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: check, get_ldap, has_value, option_enabled
# Example Call: get_user USER

# 1. Determine if system is LDAP enabled or not
# 2. Get user info from local/LDAP
# 3. Return as much info as possible

  user_check="${1}"
  get_ldap
  if `option_enabled LDAP_CLIENT`; then
    #Get user info from LDAP
    if [[ `${LDAP_SEARCH} -b ou=People,${LDAP_BASEDN} "uid=${user_check}" | grep "^uid:" | awk '{print $2}'` = "${user_check}" ]]; then
      BL_USER_DN="`${LDAP_SEARCH} -b ou=People,${LDAP_BASEDN} "uid=${user_check}" | grep "^dn:" | awk '{print $2}' | xargs`"
      BL_USER_DISPLAY_NAME="`${LDAP_SEARCH} -b ou=People,${LDAP_BASEDN} "uid=${user_check}" | grep "^displayName:" | cut -d: -f2- | xargs`"
      BL_USER_EMAIL="`${LDAP_SEARCH} -b ou=People,${LDAP_BASEDN} "uid=${user_check}" | grep "^mail:" | cut -d: -f2- | xargs`"
      BL_USER_GID="`${LDAP_SEARCH} -b ou=People,${LDAP_BASEDN} "uid=${user_check}" | grep "^gidNumber:" | cut -d: -f2- | xargs`"
      BL_USER_HOMEDIR="`${LDAP_SEARCH} -b ou=People,${LDAP_BASEDN} "uid=${user_check}" | grep "^homeDirectory:" | cut -d: -f2- | xargs`"
      BL_USER_NAME="${user_check}"
      BL_USER_SOURCE="LDAP"
      BL_USER_UID="`${LDAP_SEARCH} -b ou=People,${LDAP_BASEDN} "uid=${user_check}" | grep "^uidNumber:" | cut -d: -f2- | xargs`"
    else
      echo "   ERROR: User '${user_check}' does not exist in LDAP!"
    fi
  elif [[ `grep ^${user_check}: /etc/passwd` ]]; then
    #Get user info from local files
    entry="`grep ^${user_check}: /etc/passwd`"
    BL_USER_DISPLAY_NAME="`echo ${entry} | cut -d: -f5`"
    BL_USER_EMAIL=""
    BL_USER_GID="`echo ${entry} | cut -d: -f4`"
    BL_USER_HOMEDIR="`echo ${entry} | cut -d: -f6`"
    BL_USER_NAME="`echo ${entry} | cut -d: -f1`"
    BL_USER_SOURCE="LOCAL"
    BL_USER_UID="`echo ${entry} | cut -d: -f3`"
  else
    dbg ${FUNCNAME} ${LINENO} "get_user was unable to find '${user_check}' in /etc/passwd or LDAP"
  fi

  return 0




  #Keep asking for password for at least 3 attempts
  i=0
  while [ ${i} -lt 4 ]; do
    if [[ "${i}" -gt "2" ]] && [[ "${i}" != "0" ]]; then
      dbg ${FUNCNAME} ${LINENO} "Unable to validate the given password for user '${BL_USER_NAME}'"
      return 1
    fi
    get_password ${BL_USER_NAME}
    BL_USER_PASSWORD="${PASSWORD}"

    if [[ ${BL_USER_SOURCE} = "LDAP" ]]; then
      #Now that we have all the variables for LDAP, execute get_ldap function from bash_lib to build commands
      get_ldap

      #Test the users credentials to ensure everything works before proceeding.
      dbg ${FUNCNAME} ${LINENO} "Testing users credentials with an LDAP bind as '${LDAP_BINDDN}'" "${LDAP_SEARCH_NP} uid=${BL_USER_NAME} cn"
      ${LDAP_SEARCH} uid=${BL_USER_NAME} cn > /dev/null 2>&1
      if [[ ${?} = 0 ]]; then
        dbg ${FUNCNAME} ${LINENO} "Successfully binded as '${BL_USER_DN}'"
        logit "Successfully binded as '${BL_USER_DN}'"
        break
      else
        logit "Incorrect LDAP bind Password for ${BL_USER_NAME}; Number of attempts: ${i}"
        PASSWORD=""
        sleep 3
        let i++
      fi
    elif [[ ${BL_USER_SOURCE} = "LOCAL" ]]; then
      current_password="`grep ^${BL_USER_NAME}: /etc/shadow | cut -d: -f2`"
      if [[ `echo ${current_password} | grep ^\$6` ]]; then
        enc_type="sha512"
      elif [[ `echo ${current_password} | grep ^\$1` ]]; then
        enc_type="md5"
        entered_password="$(echo -n \"${md5}\" | md5sum )"
      else
        dbg ${FUNCNAME} ${LINENO} "Local password encryption type could not be determined; this is fatal"
        return 1
      fi
    else
      dbg ${FUNCNAME} ${LINENO} "BL_USER_SOURCE was not set to a know source; this is fatal"
      return 1
    fi
  done
  return 0
}


function has_value {
# Purpose: Check if a variable is defined (set) and value's length > 0
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: is_defined
# Example Call: has_value DEBUG
  if `is_defined ${1}`; then
    if [[ -n ${!1} ]]; then
      return 0
    fi
    return 1
  else
    return 1
  fi
}


function help {
  abort report
  echo " \n\n
Help info for ${LIB_SNAME}
  To call this library function, add the following two lines to your script
      source ${LIB_SNAME}
      export -f \`grep ^function ${LIB_SNAME} | awk '{print \$2}' | xargs\`\n
  The init function is called automatically upon sourcing, all other functions will need to be explicitly called in your script to make the variables accessible.
  All variables in this script can be over-ridden by setting them after you source this one. iVariables not called in init function can be set before.
  The setting below represent current values set for each variable.

  Abort/Exit/Return Codes/Statuses: [Available Exit codes]
    Function: abort
    Purpose: Provides a return/exit code upon calling abort
    Abort Codes
       EXIT 0:    ${abort_msg_0}
       EXIT 1:    ${abort_msg_1}
       EXIT 2:    ${abort_msg_2}
       EXIT 10:   ${abort_msg_10}
       EXIT 11:   ${abort_msg_11}
       EXIT 12:   ${abort_msg_12}
       EXIT 13:   ${abort_msg_13}
       EXIT 14:   ${abort_msg_14}
       EXIT 15:   ${abort_msg_15}
       EXIT 16:   ${abort_msg_16}
       EXIT 17:   ${abort_msg_17}
       EXIT 18:   ${abort_msg_18}
       EXIT 19:   ${abort_msg_19}
       EXIT 20:   ${abort_msg_20}
       EXIT 21:   ${abort_msg_21}
       EXIT 22:   ${abort_msg_22}
       EXIT 23:   ${abort_msg_23}
       EXIT 24:   ${abort_msg_24}
       EXIT 126:  ${abort_msg_126}
       EXIT 127:  ${abort_msg_127}
       EXIT 128:  ${abort_msg_128}
       EXIT 130:  ${abort_msg_130}
       EXIT 131:  ${abort_msg_131}
       EXIT 132:  ${abort_msg_132}
       EXIT 133:  ${abort_msg_133}
       EXIT 134:  ${abort_msg_134}
  COLORS*: See below for variables available. For a full color chart, execute print_colors after sourcing this file
    Function: init
    Purpose: Various colors can be set at the terminal by just calling these variables. See list below.
    COLOR_BLUE:       ${COLOR_BLUE} \\${COLOR_BLUE} ${COLOR_RESET}
    COLOR_BLACK:      ${COLOR_BLACK} \\${COLOR_BLACK} ${COLOR_RESET}
    COLOR_CYAN:       ${COLOR_CYAN} \\${COLOR_CYAN} ${COLOR_RESET}
    COLOR_GREEN:      ${COLOR_GREEN} \\${COLOR_GREEN} ${COLOR_RESET}
    COLOR_PURPLE:     ${COLOR_PURPLE} \\${COLOR_PURPLE} ${COLOR_RESET}
    COLOR_RED:        ${COLOR_RED} \\${COLOR_RED} ${COLOR_RESET}
    COLOR_WHITE:      ${COLOR_WHITE} \\${COLOR_WHITE} ${COLOR_RESET}
    COLOR_YELLOW:     ${COLOR_YELLOW} \\${COLOR_YELLOW} ${COLOR_RESET}
    COLOR_UN_BLUE:    ${COLOR_UN_BLUE} \\${COLOR_UN_BLUE} ${COLOR_RESET}
    COLOR_UN_BLACK:   ${COLOR_UN_BLACK} \\${COLOR_UN_BLACK} ${COLOR_RESET}
    COLOR_UN_CYAN:    ${COLOR_UN_CYAN} \\${COLOR_UN_CYAN} ${COLOR_RESET}
    COLOR_UN_GREEN:   ${COLOR_UN_GREEN} \\${COLOR_UN_GREEN} ${COLOR_RESET}
    COLOR_UN_PURPLE:  ${COLOR_UN_PURPLE} \\${COLOR_UN_PURPLE} ${COLOR_RESET}
    COLOR_UN_RED:     ${COLOR_UN_RED} \\${COLOR_UN_RED} ${COLOR_RESET}
    COLOR_UN_WHITE:   ${COLOR_UN_WHITE} \\${COLOR_UN_WHITE} ${COLOR_RESET}
    COLOR_UN_YELLOW:  ${COLOR_UN_YELLOW} \\${COLOR_UN_YELLOW} ${COLOR_RESET}
    COLOR_BO_BLUE:    ${COLOR_BO_BLUE} \\${COLOR_BO_BLUE} ${COLOR_RESET}
    COLOR_BO_BLACK:   ${COLOR_BO_BLACK} \\${COLOR_BO_BLACK} ${COLOR_RESET}
    COLOR_BO_CYAN:    ${COLOR_BO_CYAN} \\${COLOR_BO_CYAN} ${COLOR_RESET}
    COLOR_BO_GREEN:   ${COLOR_BO_GREEN} \\${COLOR_BO_GREEN} ${COLOR_RESET}
    COLOR_BO_PURPLE:  ${COLOR_BO_PURPLE} \\${COLOR_BO_PURPLE} ${COLOR_RESET}
    COLOR_BO_RED:     ${COLOR_BO_RED} \\${COLOR_BO_RED} ${COLOR_RESET}
    COLOR_BO_WHITE:   ${COLOR_BO_WHITE} \\${COLOR_BO_WHITE} ${COLOR_RESET}
    COLOR_BO_YELLOW:  ${COLOR_BO_YELLOW} \\${COLOR_BO_YELLOW} ${COLOR_RESET}
    COLOR_BG_BLUE:    ${COLOR_BG_BLUE} \\${COLOR_BG_BLUE} ${COLOR_RESET}
    COLOR_BG_BLACK:   ${COLOR_BG_BLACK} \\${COLOR_BG_BLACK} ${COLOR_RESET}
    COLOR_BG_CYAN:    ${COLOR_BG_CYAN} \\${COLOR_BG_CYAN} ${COLOR_RESET}
    COLOR_BG_GREEN:   ${COLOR_BG_GREEN} \\${COLOR_BG_GREEN} ${COLOR_RESET}
    COLOR_BG_PURPLE:  ${COLOR_BG_PURPLE} \\${COLOR_BG_PURPLE} ${COLOR_RESET}
    COLOR_BG_RED:     ${COLOR_BG_RED} \\${COLOR_BG_RED} ${COLOR_RESET}
    COLOR_BG_WHITE:   ${COLOR_BG_WHITE} \\${COLOR_BG_WHITE} ${COLOR_RESET}
    COLOR_BG_YELLOW:  ${COLOR_BG_YELLOW} \\${COLOR_BG_YELLOW} ${COLOR_RESET}
    COLOR_RESET:    ${COLOR_RESET} \\${COLOR_RESET} ${COLOR_RESET}
  DATE1: `DATE1`
    Function: DATE1
    Purpose: Provide quick version of DATE format
  DATE2: `DATE2`
    Function: DATE2
    Purpose: Provide quick version of DATE format
  DATE3: `DATE3`
    Function: DATE3
    Purpose: Provide quick version of DATE format
  DATE4: `DATE4`
    Function: DATE4
    Purpose: Provide quick version of DATE format
  DEBUG: ${DEBUG}
    Function: init
    Purpose: Enables debugging. See DEBUG variables below for using this option
  DEBUG_HOST: ${DEBUG_HOST}
    Function: init
    Purpose: If set, will only log debug messages for specified host. Defaults to localhost. This reduces noise from other clients while troubleshooting. Only one host can be specified
  DEBUG_LEVEL: ${DEBUG_LEVEL}
    Function: init
    Purpose: This sets the various debug levels available
    Debug Levels
       Level 0: No debugging
       Level 1: Display to screen only
       Level 2: Send to LOG_FILE_DEBUG only
       Level 3: Display and send to LOG_FILE_DEBUG
       Level 4: Full set -x to screen
       Level 5: Full set -x to screen and DEBUG statements
  INTERACTIVE: ${INTERACTIVE}
    Function: none
    Purpose: Determines if current envrinment can accept standard input for things such as the 'read' comamnd and/or user input.
  LDAP_ADMIN_BINDDN: \${LDAP_ADMIN_BINDDN}
    Function: get_ldap
    Purpose: The full DN of the account with admin rights to modify LDAP. NOTE: This must be defined by you before calling the function.
  LDAP_ADMIN_BINDPW: \${LDAP_ADMIN_BINDPW}
    Function: get_ldap
    Purpose: The password for LDAP_ADMIN_BINDPW. NOTE: This must be defined by you before calling the function.
  LDAP_BASEDN: ${LDAP_BASEDN}
    Function: get_ldap
    Purpose: The base dn of your LDAP server. This script will try to determine it. If variable above is empty then you will have to define. Example: dc=example,dc=com
  LDAP_BINDDN: ${LDAP_BINDDN}
    Function: get_ldap
    Purpose: The full DN of the user required to query LDAP. This is for LDAP servers that do not allow anonymous access. Example: uid=proxy,dc=example,dc=com
  LDAP_BINDPW: ${LDAP_BINDPW}
    Function: get_ldap
    Purpose: Password for the account defined in LDAP_BINDDN
  LDAP_CLIENT: ${LDAP_CLIENT}
    Function: get_ldap
    Purpose: This variable is set to true or false depending on whether a successful test result of LDAP_USER.
  LDAP_HOST: ${LDAP_HOST}
    Function: get_ldap
    Purpose: The primary hostname of the ldap server. Example: ldap1.example.com
  LDAP_PORT: ${LDAP_PORT}
    Function: get_ldap
    Purpose: The port to connect to the LDAP server on. If the variable above is blank, then script was unable to determie the port and you will have to define this variable.
  LDAP_MODIFY: ldapmodify \${ldap_tls} -x -h \${LDAP_HOST} -b \${LDAP_BASEDN} -p \${LDAP_PORT} -D \${LDAP_ADMIN_BINDDN} -w \${LDAP_ADMIN_BINDPW}
    Function: get_ldap
    Purpose: This is the variable used to call 'ldapmodify' which is built from all LDAP defined variables.
  LDAP_SEARCH: ldapsearch \${ldap_tls} -LLL -x -h \${LDAP_HOST} -p \${LDAP_PORT} -D \${LDAP_BINDDN} -w \${LDAP_BINDPW}
    Function: get_ldap
    Purpose: This is the variable used to call 'ldapsearch' which is built from all LDAP defined variables.
  LDAP_TLS: ${LDAP_TLS}
    Function: get_ldap
    Purpose: This variable defines whether TLS is in use or not.
  LDAP_USER: ${LDAP_USER}
    Function: get_ldap
    Purpose: This is an LDAP user id used to test if client is currently LDAP enabled. NOTE: This must be defined by you before calling the function.
  LOG_FILE: ${LOG_FILE}
    Function: init
    Purpose: Location where all output sent to 'logit' will go
  LOG_FILE_DEBUG: ${LOG_FILE_DEBUG}
    Function: init
    Purpose: Location where all debug output will be sent
  LOG_FILE_MASTER: ${LOG_FILE_MASTER}
    Function: init
    Purpose: Location where all output sent to 'logit -m' will go
  MSGQ: ${MSGQ}
    Function: msg_queue
    Purpose: Variable that holds all messages in the queue created by msg_queue
  OS_ADDITIONAL_IPS: ${OS_ADDITIONAL_IPS}
    Function: get_os
    Purpose: Provide additional IP's configured on the host besides the primary Example: ${OS_ADDITIONAL_IPS}
  OS_ARCH: ${OS_ARCH}
    Function: get_os
    Purpose: Provide current architecture as provided by 'uname -m'. Example: ${OS_ARCH}
  OS_CORE_QTY: ${OS_CORE_QTY}
    Function: get_os
    Purpose: This is the toal number of CPU cores present on a system. Example: ${OS_CORE_QTY}
  OS_CPU_FREQ: ${OS_CPU_FREQ}
    Function: get_os
    Purpose: This is the clock frequency of the processors on the system. Example: ${OS_CPU_FREQ}
  OS_CPU_QTY: ${OS_CPU_QTY}
    Function: get_os
    Purpose: This is the total number of CPU (Physical sockets) on the system. Example: ${OS_CPU_QTY}
  OS_CPU_TYPE: ${OS_CPU_TYPE}
    Function: get_os
    Purpose: This describes the type of CPU such as Intel. Example: ${OS_CPU_TYPE}
  OS_DEFAULT_INTERFACE: ${OS_DEFAULT_INTERFACE}
    Function: get_os
    Purpose: This is the default interface that is used by the default gateway. Example: ${OS_DEFAULT_INTERFACE}
  OS_GATEWAY: ${OS_GATEWAY}
    Function: get_os
    Purpose: This is the default gateway of the network for this system. Example: ${OS_GATEWAY}
  OS_HT_QTY: ${OS_HT_QTY}
    Function: get_os
    Purpose: This is the number of cores as presented by hyper-threading. Example: ${OS_HT_QTY}
  OS_PRIMARY_IP: ${OS_PRIMARY_IP}
    Function: get_os
    Purpose: The primary address of the host as determined by performing an nslookup on the 'hostname' command. If unable to determine, uses IP of OS_DEFAULT_INTERFACE. Example: ${OS_PRIMARY_IP}
  OS_PROC_INFO: ${OS_PROC_INFO}
    Function: get_os
    Purpose: This is a combination of all the CPU info collected into one variable. Example: ${OS_PROC_INFO}
  OS_RAM: ${OS_RAM}
    Function: get_os
    Purpose: This is the quantity of RAM that exists on the host expressed in GB. Example: ${OS_RAM}
  OS_DOMAIN: ${OS_DOMAIN}
    Function: get_os
    Purpose: Provide domain name as reported by DNS or 'hostname'. Example: ${OS_DOMAIN}
  OS_HOSTNAME: ${OS_HOSTNAME}
    Function: get_os
    Purpose: Provide fully qualified hostname as returned by DNS or 'hostname'. Example: ${OS_HOSTNAME}
  OS_INFO: ${OS_INFO}
    Function: get_os
    Purpose: Provide current OS as provided by the above OS variables and reported as human readable string. Example: ${OS_INFO}
  OS_KERNEL: ${OS_KERNEL}
    Function: get_os
    Purpose: Provide current OS as provided by 'uname -r'. Example: ${OS_KERNEL}
  OS_RELEASE: ${OS_RELEASE}
    Function: get_os
    Purpose: Provide current OS Release as provided by /etc/redhat-release. Example: ${OS_RELEASE}
  OS_SHOSTNAME: ${OS_SHOSTNAME}
    Function: get_os
    Purpose: Provide just the Short hostname as reported by DNS or 'hostname'. Example: ${OS_SHOSTNAME}
  OS_VERSION: ${OS_VERSION}
    Function: get_os
    Purpose: Provide current OS Release as a major whole number as provided by /etc/redhat-release. Example: ${OS_VERSION}
  OS_VIRTUALIZED: ${OS_VIRTUALIZED}
    Function: get_os
    Purpose: Specify what type of virtualization technology is in use if any. If not virtualized, then this will be set to physical. Example: ${OS_VIRTUALIZED}
  SSH_AGENT_FORWARD: ${SSH_AGENT_FORWARD}
    Function: init
    Purpose: Boolena set to 'true' or 'false' if SSH Agent forwarding is enabled via the equivalant of 'ssh -A'.
  TMP: ${TMP}
    Function: init
    Purpose: Set the location where all TMP files will be written to
  BL_USER_DISPLAY_NAME: Example: John Doe
    Function: get_user
    Purpose: Determines the full display name for the user returned from BL_USER_SOURCE
  BL_USER_EMAIL: Example: John.Doe@example.com
    Function: get_user
    Purpose: Determines the full email for the user returned from BL_USER_SOURCE
  BL_USER_GID: Example: 2045
    Function: get_user
    Purpose: Determines the group id for the user returned from BL_USER_SOURCE
  BL_USER_HOMEDIR: Example: /home/jdoe
    Function: get_user
    Purpose: Determines the home directory to be used for the user returned from BL_USER_SOURCE
  BL_USER_NAME: Example: jdoe
    Function: get_user
    Purpose: Determines the user name for the user returned from BL_USER_SOURCE
  BL_USER_SOURCE: Example: LDAP
    Function: get_user
    Purpose: Specifies which source the user information came from when calling get_user function
  BL_USER_UID: Example: 2045
    Function: get_user
    Purpose: Determines the group id for the user returned from BL_USER_SOURCE
  "
  exit 0
}


function init {
# Purpose: Initialization function called at the end of this function to set variables in use for the remainder of this script
# Required Variables: None
# Optional Variables: DEBUG, LOG_FILE, MASTER_LOG_FILE, DEBU_LOG_FILE
# Minimum Arguments: 0
# Functions Required: is_defined
# Example Call: init
  # Use colours in output.
  # Regular
  COLOR_BLACK="\e[0;30m"
  COLOR_BLUE="\e[0;34m"
  COLOR_CYAN="\e[0;36m"
  COLOR_GREEN="\e[0;32m"
  COLOR_PURPLE="\e[0;35m"
  COLOR_RED="\e[0;31m"
  COLOR_WHITE="\e[0;37m"
  COLOR_YELLOW="\e[0;33m"
  # Bold
  COLOR_BO_BLACK="\e[30;1m"
  COLOR_BO_BLUE="\e[1;34m"
  COLOR_BO_CYAN="\e[1;36m"
  COLOR_BO_GREEN="\e[1;32m"
  COLOR_BO_PURPLE="\e[1;35m"
  COLOR_BO_RED="\e[1;31m"
  COLOR_BO_WHITE="\e[1;37m"
  COLOR_BO_YELLOW="\e[1;33m"
  # Underline
  COLOR_UN_BLACK="\e[4;30m"
  COLOR_UN_BLUE="\e[4;34m"
  COLOR_UN_CYAN="\e[4;36m"
  COLOR_UN_GREEN="\e[4;32m"
  COLOR_UN_PURPLE="\e[4;35m"
  COLOR_UN_RED="\e[4;31m"
  COLOR_UN_WHITE="\e[4;37m"
  COLOR_UN_YELLOW="\e[4;33m"
  # Background
  COLOR_BG_BLACK="\e[40m"
  COLOR_BG_BLUE="\e[44m"
  COLOR_BG_CYAN="\e[46m"
  COLOR_BG_GREEN="\e[42m"
  COLOR_BG_PURPLE="\e[45m"
  COLOR_BG_RED="\e[41m"
  COLOR_BG_WHITE="\e[30;47m"
  COLOR_BG_YELLOW="\e[30;43m"
  # Reset Text
  COLOR_RESET="\e[0m"   # Text Reset

  #Console Color settings
  COLOR_CO_BLUE="tput setaf 4"
  COLOR_CO_BOLD="tput bold"
  COLOR_CO_CYAN="tput setaf 6"
  COLOR_CO_GREEN="tput setaf 2"
  COLOR_CO_MAGENTA="tput setaf 5"
  COLOR_CO_RED="tput setaf 1"
  COLOR_CO_RESET="tput sgr0"
  COLOR_CO_YELLOW="tput setaf 3"

  COLOR_CO_BG_BLUE="tput setab 4"
  COLOR_CO_BG_CYAN="tput setab 6"
  COLOR_CO_BG_GREEN="tput setab 2"
  COLOR_CO_BG_MAGENTA="tput setab 5"
  COLOR_CO_BG_RED="tput setab 1"
  COLOR_CO_BG_YELLOW="tput setab 3"

  var_check ${FUNCNAME} 3 DEBUG
  var_check ${FUNCNAME} 3 DEBUG_HOST
  var_check ${FUNCNAME} 3 DEBUG_LEVEL
  var_check ${FUNCNAME} 2 LOG_FILE
  var_check ${FUNCNAME} 2 LOG_FILE_DEBUG
  var_check ${FUNCNAME} 3 LOG_FILE_MASTER
  export PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:${PATH}"

  # Debug mode shows more verbose output to screen and log files.
  if ! `is_defined DEBUG` ; then
    DEBUG="false"
  fi
#  if [[ ! `is_defined DEBUG_HOST` ]]; then
#    DEBUG_HOST="`hostname`"
#  fi
  if ! `is_defined DEBUG_LEVEL` ; then
    #For available options here, see debug function
    DEBUG_LEVEL="0"
  fi

  #Log locations
  if ! `is_defined LOG_FILE` ; then
    LOG_FILE=${LIB_SNAME}.log
  fi
  if ! `is_defined LOG_FILE_MASTER` ; then
    LOG_FILE_MASTER=${LIB_SNAME}-MASTER.log
  fi
  if ! `is_defined LOG_FILE_DEBUG` ; then
    init_msg="LOG_FILE_DEBUG is not defined; using ${LIB_SNAME}-DEBUG.log"
    echo "${LIB_SNAME} ${FUNCNAME} ${COLOR_CYAN}INFO: ${COLOR_RESET} ${init_msg}"
    LOG_FILE_DEBUG=${LIB_SNAME}-DEBUG.log
  fi

  #Define tmp location to be used
  TMP="/tmp"

  #Check if SSH agent forwarding is enabled
  if [[ -S ${SSH_AUTH_SOCK} ]]; then
    SSH_AGENT_FORWARD="true"
  else
    SSH_AGENT_FORWARD="false"
  fi
  export SSH_AGENT_FORWARD

  set +o histexpand
  return 0
}


function insert {
# Purpose: Insert string at line number of file; line number is optional, will append to end by default
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 2
# Functions Required: None
# Example Call: insert "umask 077" /etc/profile 5
  if [[ ${3} = "1" ]]; then
    logit "INSERT: Cannot insert into line number \'${3}\'."
    return 1
  elif [[ ${3} = "" ]]; then
    insert_line="$"
  else
    insert_line="${3}"
  fi
  sed -i "${insert_line}a\\${1}" $2
  return 0
}


function is_defined {
# Purpose: Checks whether a variable has been defined
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: is_defined DEBUG
  if [[ ${!1-X} == ${!1-Y} ]]; then
    #echo "$1 DEFINED"
    return 0
  else
    #echo "$1 UNDEFINED"
    return 1
  fi
}


function is_number {
# Purpose: Check if a variable is numberical or not
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: is_number 12345
  if [ "${1}" -eq "${1}" ] 2>/dev/null; then
    # ${1} is an integer
    return 0
  else
    return 1
  fi
}


function logit {
# Purpose: Function for logging errors
# Required Variables: LOG_FILE & MASTER_LOG_FILE
# Optional Variables: See usage below
# Minimum Arguments: 1
# Functions Required: check, DATE2, get_os, is_defined, option_enabled
# Example Call: logit "This will be logged to LOG_FILE"

# Usage
# logit "message"     # Default; log message to screen and LOG_FILE
# logit -f [FILE]     # Will send log messages to the FILE specified
# logit -m "message"  # Log to master log file instead of client log
# logit -s "message"  # Log only, no screen output
  if ! `is_defined OS_SHOSTNAME`; then
    #OS function has not been executing, doing so now
    get_os
  fi

  log_only="false"
  if [[ ${1} = "-m" ]]; then
    #Log to master log file instead of client
    LOGIT_LOG_FILE="${MASTER_LOG_FILE}"
    logit_message="${2}"
  elif [[ ${1} = "-s" ]]; then
    #Only log to file, not screen
    LOGIT_LOG_FILE="${LOG_FILE}"
    log_only="true"
    logit_message="${2}"
  elif [[ ${1} = "-f" ]]; then
    #Log everything to FILE specified
    LOGIT_LOG_FILE="${2}"
    logit_message="${3}"
  else
    #Log to client file and screen
    LOGIT_LOG_FILE="${LOG_FILE}"
    logit_message="${1}"
  fi

  #Put to screen if needed
  if ! `option_enabled log_only`; then
    echo "$(DATE2) ${OS_SHOSTNAME} ${SNAME} -- ${logit_message}"
  fi

  #Log to file
  echo "$(DATE2) ${OS_SHOSTNAME} ${SNAME} ${logit_message}" >> ${LOGIT_LOG_FILE}
  if [[ ${?} != 0 ]]; then
    echo "Unable to write to ${LOGIT_LOG_FILE}"
    exit 1
  fi
  return 0
}


function mailcmd {
# Purpose: Function for sending mail with or without attachments on RHEL5/6
# Required Variables: MAIL_SUBJECT, MAIL_MESSAGE, MAIL_TO, MAIL_FROM
# Optional Variables: See below
# Minimum Arguments: 3
# Functions Required: is_defined, has_value, get_os, logit, check
# Example Call: mailcmd "This is the subject" "This is the message" "william.h.bentley@example.com" "UNIX SUPPORT" "file_attachment.tar"
  if ! `is_defined OS_HOSTNAME` ; then
    #OS function has not been executing, doing so now
    get_os
  fi

  mailcmd_subject="${1}"
  mailcmd_msg="${2}"
  mailcmd_to="${3}"
  mailcmd_from="${4}"
  mailcmd_attachment="${5}"

  #If no email was passed then assume there is nothing to do
  if ! `has_value mailcmd_to`; then
    return 1
  fi

  # Validate that email addresses are good
  for email in ${mailcmd_to}; do
    if [[ `echo ${email} | grep -v '@'` ]]; then
      logit "Email address '${email}' is missing '@'"
      return 1
    fi
  done

  #If critical variables are blank; error out
  if ! `has_value mailcmd_subject`; then
    check ${LINENO} failed "A critical variable for the ${FUNCNAME} is missing: \${mailcmd_subject}."
  elif ! `has_value mailcmd_to`; then
    check ${LINENO} failed "A critical variable for the ${FUNCNAME} is missing: \${mailcmd_to}."
  fi

  if [[ ${OS_VERSION} -gt "5" ]]; then #RHEL 6 Email
    #Known bug with mailx if debug is set in any env variable. RH Case 01084107
    if ! `has_value mailcmd_attachment`; then #No attachment
      echo "${mailcmd_msg}" | mail -s "${mailcmd_subject}" -S from="DoNotReply (${mailcmd_from})" "${mailcmd_to}"
    else #With attachment
      #Deal with multiple attachments
      mailcmd_attachment="`echo ${mailcmd_attachment} | perl -pe 's/ /\n/g' | perl -pe 's/^/-a /g' | xargs`"
      echo "${mailcmd_msg}" | mail -s "${mailcmd_subject}" ${mailcmd_attachment} -S from="DoNotReply (${mailcmd_from})" "${mailcmd_to}"
    fi
  else #RHEL 5 Email
    if ! `has_value mailcmd_attachment`; then #No attachment
      echo "${mailcmd_msg}" | mail -s "${mailcmd_subject}" "${mailcmd_to}" -- -F "${mailcmd_from}"
    else #With attachment
      rm ${TMP}/out.mail 2>/dev/null
      for attachment in ${mailcmd_attachment}; do
        uuencode ${attachment} `basename ${attachment}` >> ${TMP}/out.mail
      done
      (echo "${mailcmd_msg}"; cat ${TMP}/out.mail)  | mail -s "${mailcmd_subject}" "${mailcmd_to}" -- -F "${mailcmd_from}"
    fi
  fi
  return 0
}


function msg_queue {
# Purpose: Build a list (queue) of messages.
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: msg_queue "This is message 1"
  MSGQ="${MSGQ}${1}\n"
  return 0
}


function option_enabled {
# Purpose: Checks if a variable is set to "y" or "yes" or "true".
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: to_lower
# Example Call: option_enabled DEBUG
  option_var="${1}"
  option_var_value=$(eval echo \$${option_var})
  option_var_value=`to_lower ${option_var_value}`
  if [[ "${option_var_value}" == "y" ]] || [[ "${option_var_value}" == "yes" ]] || [[ "${option_var_value}" == "true" ]]; then
    return 0
  else
    return 1
  fi
}


function pause {
# Purpose: Prompt the user if they want to continue or not; waits for input
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 0
# Functions Required: None
# Example Call: pause
  echo "\n\n"
  read -s -n 1 -p "Press any key to continue..."
  echo "\n\n"
  return 0
}


function print_colors {
# Purpose: Call this function to get all the console color settings available
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 0
# Functions Required: None
# Example Call: print_colors
  local fgc bgc vals seq0
  printf "Color escapes are %s\n" '\e[${value};...;${value}m'
  printf "Values 30..37 are foreground colors\n"
  printf "Values 40..47 are background colors\n"
  printf "Value  1 gives a  bold-faced look\n\n"

  # foreground colors
  for fgc in {30..37}; do
    # background colors
      for bgc in {40..47}; do
        fgc=${fgc#37} # white
        bgc=${bgc#40} # black
        vals="${fgc:+$fgc;}${bgc}"
        vals=${vals%%;}
        seq0="${vals:+\e[${vals}m}"
        printf "  %-9s" "${seq0:-(default)}"
        printf " ${seq0}TEXT\e[m"
        printf " \e[${vals:+${vals+$vals;}}1mBOLD\e[m"
      done
    echo; echo
  done
  return 0
}


function strip {
# Purpose: Strip a line from a file
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 2
# Functions Required: None
# Example Call: strip "root" /etc/passwd
# Usage: strip "string" file
  #backup $2
  if [[ -f ${2} ]]; then
    grep -v "${1}" $2 > ${TDIR}/tmpfile
    cat ${TDIR}/tmpfile > $2
    rm ${TDIR}/tmpfile
  fi
  return 0
}


function to_lower {
# Purpose: Returns lowercase string
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: to_lower "HELLO"
  echo "${1}" | tr '[:upper:]' '[:lower:]'
  return 0
}


function to_upper {
# Purpose: Returns uppercase string
# Required Variables: None
# Optional Variables: None
# Minimum Arguments: 1
# Functions Required: None
# Example Call: to_upper "hello"
  echo "${1}" | tr '[:lower:]' '[:upper:]'
  return 0
}


function usage {
  echo "\n\nUSAGE: ${LIB_SNAME} [-h | --help] [-i | --import] [-l | --list] [-v | --version]\n"
  echo "     -h | --help      Show additonal details on how to call this script and variable information"
  echo "     -i | --import    When run interactively, will execute the init function"
  echo "     -l | --list      List available functions and usage"
  echo "     -v | --version   What version of this script is running"
  echo
  return 0
}


function var_check {
#This is an internal lib function for handling errors within this script
  check_function_name="${1}"
  check_severity="${2}"
  check_variable="${3}"
  is_defined ${check_variable}
  check_defined_rc="${?}"
  has_value ${check_variable}
  check_value_rc="${?}"
  if [[ ${check_defined_rc} != 0 ]] || [[ ${check_value_rc} != 0 ]]; then
    check_msg="The following variable is not defined: ${check_variable}"
    if [[ ${check_severity} = "1" ]]; then
      check_severity="${COLOR_RED}CRITICAL:${COLOR_RESET} "
    elif [[ ${check_severity} = "2" ]]; then
      check_severity="${COLOR_YELLOW}WARNING:${COLOR_RESET} "
    elif [[ ${check_severity} = "3" ]]; then
      check_severity="${COLOR_CYAN}INFO: ${COLOR_RESET}"
    fi
    echo "${LIB_SNAME} ${check_function_name} ${check_severity} ${check_msg}"
    if [[ ${check_severity} = "CRITICAL" ]]; then
      return 1
    else
      return 0
    fi
  else
    return 0
  fi
}


#If script was not sourced from somewhere then run through cmd line args
if [[ ${lib_sourced} = "true" ]]; then
  init
else
  case "${1}" in
    -h | --help)
      init
      get_os
      get_ldap
      help
    ;;
    -i | --import)
      init
    ;;
    -l | --list)
      echo "\n\nFunction List for ${LIB_SNAME}\n"
      grep -A5 -B1 ^'# Purpose' ${LIB_SNAME} | perl -pe 's/{//g' | perl -pe 's/--/ /g'
    ;;
    -v | --version)
      echo "\n\n   ${LIB_SNAME} Version: ${LIB_SVER}\n"
    ;;
    -*)
       echo "\n\nError: Unknown option: ${1}" >&2
       usage
    ;;
    *)
       echo "\n\nError: Must provide an argument when not sourced from another script" >&2
       usage
    ;;
  esac
fi
